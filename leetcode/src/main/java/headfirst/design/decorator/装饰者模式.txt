

装饰者模式：
	动态将职责添加到对象身上，扩展功能上比继承更加灵活。
	
意图：
	动态给对象添加一直职责。
	
	
	利用继承设计子类的行为，是在编译时静态决定的，所有的子类都会继承到相同的行为。
	利用组合扩展对象的行为，就可以在运行时动态地进行扩展。
	
	
	装饰者和被装饰者要有相同的超类型。 	
	
	
	适用性：
	 需扩展一个类的功能，附加额外的职责。
	 可以动态给对象添加功能，也可以动态撤销。
	 
	 优点：
	1. Decorator模式与继承关系的目的都是要扩展对象的功能，但是Decorator可以提供比继承更多的灵活性。
	
	2. 通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。

	缺点：
	1. 这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。
	
	2. 装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。
	
	3. 装饰模式是针对抽象组件（Component）类型编程。但是，如果你要针对具体组件编程时，就应该重新思考你的应用架构，以及装饰者是否合适。
	当然也可以改变Component接口，增加新的公开的行为，实现“半透明”的装饰者模式。在实际项目中要做出最佳选择。