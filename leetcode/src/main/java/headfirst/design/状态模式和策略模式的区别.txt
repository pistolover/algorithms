Java中的策略模式是对一组相关的算法进行封装，给调用方提供了运行时的灵活性。
调用方可以在运行时选择不同的算法，而不用修改使用策略的那个Context类。
使用策略模式的经典例子包括实现加密算法，压缩算法，以及排序算法。另一方面，状态模式使用一个对象可以在不同的状态下表现出不同的行为。
真实世界里的对象也是有状态的，并且它们会随着状态的不同而有不同的表现，比方说自动售货机，它只会在hasCoin状态下才能出售物品，如果你不塞硬币进去它是不会售货的。
现在你可以很清楚地看到策略模式和状态模式的区别了，它们的目的是不一样的。状态模式可以帮助对象来管理它的状态，而策略模式使得客户端可以选择不同的行为。
还有一个不太容易看到的区别是，谁去驱动行为的改变。
在策略模式中，是客户端驱动的，它给上下文信息提供了不同的策略，而在状态模式中，状态的迁移是由Context或者State对象自己来管理的。
同样的，如果你在State对象里面进行状态的修改，它必须持有Context的引用，也就是说对自动售货机而言，它可以调用setState方法来修改当前Context的状态。
另一方面，策略对象不会持有Context的引用 ，它的客户端将选中的策略传递给Context。

策略模式封装了一系列的相关的算法，使用客户端可以在运行时通过组合和委托来使用不同的行为，而状态模式使得对象可以在不同的状态下展现出不同的行为。
这两个模式的另一个不同之处在于状态模式封装的是对象的状态，而策略模式封装的是一个算法或者策略。由于状态是和对象耦合在一起的，它无法重用，而通过策略或者算法独立于它的上下文，使得它们可以重复使用。
状态模式中，状态本身会包含Context的引用，从而实现状态迁移 ，但策略模式则没有Context的引用
具体的策略可以作为一个参数传递给使用它们的对象，比如说Collections.sort()接受一个Comparator，这是一个策略。另状态本身 是 Context对象的一部分，随着时间的迁移，Context对象会从一个状态迁移迁移到另一个状态下。
尽管两种模式都遵循了开闭原则，策略模式还遵循了单一职责原则，因为每个策略都 封装的是独立 的算法，不同的策略独立于其它策略。改变一个策略并不会影响到另一个策略的实现。
从理论上说，策略模式和状态模式还有一个不同，前者定义的是一个对象“如何”去做一件事情，比如说如何对数据进行排序，而另一方面，状态模式定义的是“什么”以及“何时“，比如说一个对象能做什么，某个时间点它处于哪个状态。
状态的迁移顺序在状态模式中是定义好的，而策略模式则没有这样的要求。客户端可以随便选择使用哪个策略。
常见的策略模式的例子都是封装算法，比如说排序算法，加密算法，或者压缩算法。如果你发现代码中需要使用到不同的算法，那么你可以考虑使用策略模式。而如果你需要管理状态进行状态间的迁移，而不希望嵌套许多条件语句，那么状态模式就是你的首选，因为它非常简单.
最后也是最重要的一个区别在于，策略模式是由客户端进行处理的，而状态的改变Context或者State对象都可以进行。